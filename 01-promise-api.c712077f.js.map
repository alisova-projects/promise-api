{"version":3,"sources":["js/01-promise-api.js"],"names":["onFulfilled","result","console","log","onRejected","error","promise","Promise","resolve","reject","canFulfill","Math","random","setTimeout","then","x","Error","y","catch","finally"],"mappings":";AAsCA,SAASA,EAAYC,GACnBC,QAAQC,IAASF,KAAAA,OAAAA,IAGnB,SAASG,EAAWC,GAClBH,QAAQC,IAASE,KAAAA,OAAAA,IAWlB,IAAMC,EAAU,IAAIC,QAAQ,SAACC,EAASC,GAC/BC,IAAAA,EAAaC,KAAKC,SAAW,GAEnCC,WAAW,WACLH,GACJF,EAAQ,kEAGVC,EAAO,qDACJ,OAsBLH,EACGQ,KAAKd,GACLc,KAAK,SAAAC,GAIE,MAHNb,QAAQC,IAAIY,GAGN,IAAIC,MAAM,2BAIjBF,KAAK,SAAAG,GACJf,QAAQC,IAAIc,KAEbC,MAAM,SAAAb,GAASH,OAAAA,QAAQC,IAAIE,KAC3Bc,QAAQ,WAAMjB,OAAAA,QAAQC,IAAI","file":"01-promise-api.c712077f.js","sourceRoot":"..\\src","sourcesContent":["/*\n * Создание промиса\n *  - Класс Promise\n *  - resolve\n *  - reject\n *  - Promise.prototype.then(onResolve, onReject)\n */\n\n// const promise = new Promise((resolve, reject) => {\n//   const canFulfill = Math.random() > 0.5;\n\n//   setTimeout(() => {\n//     if (canFulfill) {\n//     resolve('Промис выполнился успешно, с результатом (исполнен, fulfilled)');\n//   }\n\n//   reject('Промис выполнился с ошибкой (отклонён, rejected)');\n//   }, 2000);\n// });\n\n/*\n  Планирование: если промис выполнился успешно - выполни первую ф-ю,\n  если не успешно - 2ую. В result идёт результат resolve,\n  а в error идёт результат reject.\n  Это 2е инлайн функции, которые можно сделать внешними(пример ниже).\n*/\n/*\npromise.then(\n  result => {\n  console.log(`✅ ${result}`);\n  },\n  error => {\n    console.log(`❌ ${error}`);\n  });\n  */\n\n// promise.then(onFulfilled, onRejected);\n\nfunction onFulfilled(result) {\n  console.log(`✅ ${result}`);\n}\n\nfunction onRejected(error) {\n  console.log(`❌ ${error}`);\n}\n\n//======================================================================================\n \n/*\n * Цепочки промисов (chaining)\n * Promise.prototype.catch(error) - отлавливает ошибку один раз в конце цепочки\n * Promise.prototype.finally() - снимает загружщик вконце, не зависимо от исхода операции\n */\n\n const promise = new Promise((resolve, reject) => {\n  const canFulfill = Math.random() > 0.5;\n\n  setTimeout(() => {\n    if (canFulfill) {\n    resolve('Промис выполнился успешно, с результатом (исполнен, fulfilled)');\n  }\n\n  reject('Промис выполнился с ошибкой (отклонён, rejected)');\n  }, 2000);\n});\n\n // then возвращает ещё один промис, выполненный успешно\n/*\npromise.\n  then(result => {\n    console.log(result);\n    \n    return 5;\n  }).\n  then(x => {\n    console.log(x);\n\n    return 10;\n  }).\n  then(y => {\n    console.log(y);\n  });\n  */\n\n// обработаем ошибку \npromise\n  .then(onFulfilled)\n  .then(x => {\n    console.log(x);\n\n    //вручную выбрасывается ошибка в JS \n    throw new Error('Ошибка во втором then');\n\n    return 10;\n  })\n  .then(y => {\n    console.log(y);\n  })\n  .catch(error => console.log(error))\n  .finally(() => console.log('Я буду выполнен в любом случае'));\n"]}